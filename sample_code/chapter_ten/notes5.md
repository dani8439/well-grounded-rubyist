### *Economizing on intermediate objects* ###
Remember that many methods from the `Enumerable` module return an enumerator if you call them without a block. In most such cases, there's no reason to chain the enumerator directly to another method, `names.each.inject`, for example, might as well be `names.inject`. Similarly, `names.map.select` doesn't buy you anything over `names.select`. The `map` enumerator doesn't have any knowledge of what function to map to; therefore, it can't do much other than pass the original array of values down the chain.

But consider `names.each_slice(2)`. The enumerator generated by this expression does carry some useful information; it knows that it's expected to produce two-element-long slices of the `name` array. If you place it inside a method chain, it has an effect:

```irb
>> names = %w{ David Black Yukihiro Matsumoto }
=> ["David", "Black", "Yukihiro", "Matsumoto"]
>> names.each_slice(2).map do |first, last|
?> "First name: #{first}, last name: #{last}\n"
>> end
=> ["First name: David, last name: Black\n", "First name: Yukihiro, last name: Matsumoto\n"]
```
The code block attached to the map operation gets handed from the names array two at a time, because of the `each_slice(2)` enumerator. The enumerator can proceed in a "lazy" fashion: rather than create an entire array of two-element slices in memory, it can create the slices as they're needed by the map operation.

**Enumerator literacy**
One consequence of the way enumerators work, and of their being returned automatically from blockless iterator calls, is that it takes a little practice to read enumerator code correctly. Consider this snippet, which returns an array of integers:

```irb
>> string = "An arbitrary string"
=> "An arbitrary string"
>> string.each_byte.map {|b| b + 1 }
=> [66, 111, 33, 98, 115, 99, 106, 117, 115, 98, 115, 122, 33, 116, 117, 115, 106, 111, 104]
```
Probably not useful business logic...but the point is that it looks much like `string.each_byte` is returning an array. The presence of `map` as the next operation, although not conclusive evidence of an array, certainly evokes the presence of a collection on the left.

Let's put it another way. Judging by its appearance, you might expect that if you peel off the whole `map` call, you'll be left with a collection.

In fact, `string.each_byte` returns an enumerator. The key is that an enumerator *is* a collection. It's an enumerable object as much as an array or a hash is. It just may take a little getting used to

-----
