### *Economizing on intermediate objects* ###
Remember that many methods from the `Enumerable` module return an enumerator if you call them without a block. In most such cases, there's no reason to chain the enumerator directly to another method, `names.each.inject`, for example, might as well be `names.inject`. Similarly, `names.map.select` doesn't buy you anything over `names.select`. The `map` enumerator doesn't have any knowledge of what function to map to; therefore, it can't do much other than pass the original array of values down the chain.

But consider `names.each_slice(2)`. The enumerator generated by this expression does carry some useful information; it knows that it's expected to produce two-element-long slices of the `name` array. If you place it inside a method chain, it has an effect:

```irb
>> names = %w{ David Black Yukihiro Matsumoto }
=> ["David", "Black", "Yukihiro", "Matsumoto"]
>> names.each_slice(2).map do |first, last|
?> "First name: #{first}, last name: #{last}\n"
>> end
=> ["First name: David, last name: Black\n", "First name: Yukihiro, last name: Matsumoto\n"]
```
The code block attached to the map operation gets handed from the names array two at a time, because of the `each_slice(2)` enumerator. The enumerator can proceed in a "lazy" fashion: rather than create an entire array of two-element slices in memory, it can create the slices as they're needed by the map operation.

**Enumerator literacy**
One consequence of the way enumerators work, and of their being returned automatically from blockless iterator calls, is that it takes a little practice to read enumerator code correctly. Consider this snippet, which returns an array of integers:

```irb
>> string = "An arbitrary string"
=> "An arbitrary string"
>> string.each_byte.map {|b| b + 1 }
=> [66, 111, 33, 98, 115, 99, 106, 117, 115, 98, 115, 122, 33, 116, 117, 115, 106, 111, 104]
```
Probably not useful business logic...but the point is that it looks much like `string.each_byte` is returning an array. The presence of `map` as the next operation, although not conclusive evidence of an array, certainly evokes the presence of a collection on the left.

Let's put it another way. Judging by its appearance, you might expect that if you peel off the whole `map` call, you'll be left with a collection.

In fact, `string.each_byte` returns an enumerator. The key is that an enumerator *is* a collection. It's an enumerable object as much as an array or a hash is. It just may take a little getting used to

-----
`Enumerable` methods that take arguments and return enumerators, like `each_slice`, are candidates for this kind of compression or optimization. Even if an enumerable method doesn't return an enumerator, you can create one for it, incorporating the argument so that it's remembered by the enumerator. You've seen an example of this technique already, approached from a slightly different angle:

`e = names.enum_for(:inject, "Names: ")`

The enumerator remembers not only that it's attached to the `inject` method of `names` but also that it represents a call to `inject` with an argument of `"Names"`.

In addition to the general practice of including enumerators in method chains, the specialized method `with_index`-one of the few that the `Enumerator` class implements separately from those in `Enumerable`-adds considerable value to enumerations.

### *Indexing enumerable with with_index* ###
In the days when Rubyists used the `each_with_index` method, a number of us lobbied for a corresponding `map_with_index` method. We never got it-but we ended up with something even better. Enumerators have a `with_index` method that adds numerical indexing, as a second block parameter, to any enumeration. Here's how you would use `with_index` to do the letter/number mapping:

`('a'..'z').map.with_index {|letter,i| [letter,i] }` <--Output [["a",0], ["b",1], etc.]

Note that it's `map.with_index` (two methods, chained), not `map_with_index` (a composite method name.) And `with_index` can be chained to any enumerator. Remember the musical scale from earlier? Let's say we enumerator-ize the `play` method:

```ruby
def play
  NOTES.to_enum
end
```
The original example of walking through the notes will now work without the creation of an intermediate enumerator:

`scale.play {|note| puts "Next note: #{note}" }`

And now this will work too:

`scale.play.with_index(1) {|note,i| puts "Note #{i}: #{note}" }` <-- Provide 1 as the first value for the index

The output will be an numbered list of notes:

```irb
Note 1: c
Note 2: c#
Note 3: d
Note 4: d#
Note 5: e
Note 6: e#
Note 7: f
Note 8: f#
Note 9: g
Note 10: a
Note 11: a#
Note 12: b
```

Thus the `with_index` method generalizes what would otherwise be a restricted functionality.

We'll look at one more enumerator chaining example, which nicely pulls together several enumerator and iteration techniques and also introduces a couple of new methods you may find handy.

### *Exclusive-or operations on strings with enumerators* ###
Running an exclusive-or (or *XOR*) operation on a string means XOR-ing each of its bytes with some value. XOR-ing a byte is a bitwise operationL each byte is represented by an integer, and the result of the XOR operation is an exclusive-or-ing of that integer with another number.

If your string is `"a"`, for example, it contains one byte with the value 97. The binary representation of 97 is 1100001. Let's say we want to XOR it with the character `#`, which has an ASCII value of 35, or 100011 in binary. Looking at it purely numerically, and not in terms of strings, we're doing 97^35, or 1100001^100011 in binary terms.

An XOR produces a result that, in binary representation (that is, in terms of its bits) contains a 1 where either of the source numbers, *but not both*, contained a 1, and a 0 where both of the source numbers contained the same value, whether 0 or 1. In the case of our two numbers, the XOR operation produces 1000010 or 66.

A distinguishing property of bitwise XOR operations is that if you perform the same operation twice, you get back the original value. In other words, (a^b)^b == a. Thus if we xor 66 with 35, we get 97. This behavior makes xor-ing strings a useful obfuscation technique, especially if you xor a long string byte for byte against a second string. Say your string is `"This is a string."` If you xor it character for character against, say, `#%.3u` repeating the xor string as necessary to reach the length of the original string, you get the rather daunting results `wMG@UJV\x0ERUPQ\\Z\eD\v`. if you xor that monstrosity against `#%.3u` again, you get back `"This is a string."`

Now let's write a method that will do this. We'll add it to the `String` class-not necessarily the best way to go about changing the functionality of core Ruby objects (as you'll see in chapter 13), but expedient for purposes of illustration. The following listing shows the instance method `String#^`.

```ruby
class String
  def ^(key)                                                #1.
    kenum = key.each_byte.cycle                             #2.
    each_byte.map {|byte| byte ^ kenum.next }.pack("C*")    #3
  end
end
```
The method takes one argument: the string that will be used as the basis of the xor operation (the *key*) (#1). We have to deal with cases where the key is shorter than the original string by looping through the key as many times as necessary to provide each enough characters for the whole operation. That's where enumerators come in.

The variable `keynum` is bound to an enumerator based on chaining two methods off the key string: `each_byte`, which itself returns an enumerator traversing the string byte by byte, and `cycle`, which iterates over and over again through a collection, resuming at the beginning when it reaches the end (#2). The enumerator `kenum` embodies both of these operations: each iteration through it provides another bite from the string; and when it's finished providing all the bytes, it goes back to the beginning of the string and iterates over the bytes again. That's exactly the behavior we want, to make sure we've got enough bytes to match whatever string we're xor-ing, even if it's a string that's longer than the key. In effect, we've made the key string infinitely long.

Now comes the actual xor operation (#3). Here, we use `each_byte` to iterate over the bytes of the string that's being xor'ed. The enumerator returned by `each_byte` gets chained to `map`. Inside the `map` block, each byte of the original string is xor'ed with the "next" byte from the enumerator that's cycling infinitely through the bytes of the key string. The whole `map` operation, then, produces an array of xor'ed bytes. All that remains is to put those bytes back into a result string.

Enter the `pack` method. This method turns an array into a string, interpreting each element of the array in a manner specified by the argument. In this case, the argument is `"C*"`, which means *treat each element of the array as an unsigned integer representing a single character* (that's the "C"), *and process all of them* (that's the `"*"`). Packing the array into a string of characters is thus the equivalent of transforming each array element into a character and then doing a join on the whole array.

Now we can xor strings. Here's what the process looks like:

```irb
>> str = "Nice little string."
=> "Nice little string."
>> key = "secret!"
=> "secret!"
>> x = str ^ key
=> "=\f\x00\x17E\x18H\a\x11\x0F\x17E\aU\x01\f\r\x15K"
>> orig = x ^ key
=> "Nice little string."
```
As you can see, XOR-ing twice with the same key gets you back to the original string. And it's all thanks to a two-line method that uses three enumerators!

**Forcing an encoding**
The `String#^` as implemented in the previous snipped is vulnerable to encoding issues: if you xor, say, a UTF-8 string against an ASCII string twice, you'll get back a string encoded in ASCII-8BIT. To guard against this, ad a call to `force_encoding`:

`each_byte.map {|byte| byte ^ keynum.next }.pack("C*").force_encoding(self.encoding)`

This will ensure that the byte sequence generated by the mapping gets encoded in the original string's encoding.

----

Enumerators add a completely new tool to the already rich Ruby toolkit for collection management and iteration. They're conceptually and technically different from iterators, but if you try them out on their own terms, you're sure to find uses for them alongside the other collection-related techniques you've seen.

We'll conclude our look at enumerators with a variant called a lazy enumerator. 

## *Lady enumerators* ##
Lazy enumerators make it easy to enumerate selectively over infinitely large collections. To illustrate what this means, let's start with a case where an operation tries to enumerate over an infinitely large collection and gets stuck. What if you want to know the first 10 multiples of 3? To use an infinite collection we'll create a range that goes from 1 to the special value `Float::INFINITY`. Using such a range, a first approach to the task at hand might be

`(1..Float::INFINITY).select {|n| n % 3 == 0 }.first(10)`

But this line of code runs forever. The `select` operation never finishes, so the chained-on `first` command never gets executed.

You can get a finite result form an infinite collection by using a lazy enumerator. Calling the `lazy` method directly on a range object will produce a lazy enumerator over that range:

```irb
>> (1..Float::INFINITY).lazy
=> #<Enumerator::Lazy: 1..Infinity>
```

You can then wire this lazy enumerator up to `select`, creating a cascade of lazy enumerators:

```irb
>> (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }
=> #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>
```

Since we're now lazily enumerating, it's possible to grab result sets from our operations without waiting for the completion of infinite tasks. Specifically, we can now ask for the first 10 results from the select test on the infinite list, and the infinite list is happy to enumerate only as much as is necessary to produce those 10 results:

```irb
>> (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }.first(10)
=> [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
```

As a variation on the same theme, you can create the lazy `select` enumerator and then use `take` on it. This allows you to choose how many multiples of 3 you want to see without hard-coding the number. Note that you have to call `force` on the result of `take`; otherwise you'll end up with yet another lazy enumerator, rather than an actual result set:

```irb
>> my_enum = (1..Float::INFINITY).lazy.select {|n| n % 3 == 0 }
=> #<Enumerator::Lazy: #<Enumerator::Lazy: 1..Infinity>:select>
>> my_enum.take(5).force
=> [3, 6, 9, 12, 15]
>> my_enum.take(10).force
=> [3, 6, 9, 12, 15, 18, 21, 24, 27, 30]
```

Lazy enumerators are a somewhat specialized tool, and you probably won't need them too often. But they're very handy if you have an infinite collection and want to deal only with a finite result set from operations on that collection.

### *FizzBuzz with a lazy enumerator* ###
The `FizzBuzz` problem, in its classic form, involves printing out the integers from 1 to 100... escept you apply the following rules:

  • If the number is divisible by 15, print `"FizzBuzz"`

  • Else if the number is divisible by 3, print `"Fizz"`.

  • Else if the number is divisible by 5, print `"Buzz"`.

  • Else print the number

You can use a lazy enumerator to write a version of `FizzBuzz` that can handle any range of numbers. HEre's what it might look like:

```ruby
def fb_calc(i)
  case 0
  when i % 15
    "FizzBuzz"
  when i % 3
    "Fizz"
  when i % 5
    "Buzz"
  else
    i.to_s
  end
end

def fb(n)
  (1..Float::INFINITY).lazy.map {|i| fb_calc(i) }.first(n)
end
```
Now you can examine, say, the `FizzBuzz` output for the first 15 positive integers like this:

`p fb(15)`

The output will be:

```irb
["1", "2", "Fizz", "4", "Buzz", "Fizz", "7", "8", "Fizz", "Buzz", "11", "Fizz", "13", "14", "FizzBuzz"]
```

Without creating a lazy enumerator on the range, the map operation would go on forever. Instead, the lazy enumeration ensures that the whole process will stop once we've got what we want.

## *Summary* ##
In this chapter you've seen 

• The `Enumerable` module and its instance methods 

• Using `Enumerable` in your own classes

• Enumerator basics 

• Creating enumerators 

• Iterating over strings

• Lazy enumerators 

This chapter focused on the `Enumerable` module and the `Enumerator` class, two entities with close ties. First, we explored the instance methods of `Enumerable`, which are defined in terms of an `each` method and which are available to your objects as long as those objects respond to `each` and your class mixes in `Enumerable`. Second, we looked at enumerators, objects that encapsulate the iteration process of another object, binding themselves-specifically, their `each` methods-to a designated method on another object and using that parasitic `each`-binding to deliver the full range of enumerable functionality.

Enumerators can be tricky. They build entirely on `Enumerable`; and in cases where an enumerator gets hooked up to an object that has overriden some of `Enumerable`'s methods, it's important to remember that the enumerator will have its own ideas of what those methods are. It's not a general-purpose proxy to another object; it siphons off values from one method on the other object.

One way or another-be it through the use of the more classic Ruby style of iteration and collection management-you'll almost certainly use the enumeration-related facilities of the language virtually every time you write a Ruby program. It's worth getting to know `Enumerable` intimately; it's as powerful a unit of functionality as there is anywhere in Ruby.

We'll turn next to the subject of regular expressions and pattern matching. As you'll see, there's osme payoff to looking at both strings and collection objects prior to studying regular expressions: a number of pattern-matching methods performed on strings return their results to you in collection form and therefore lend themselves to iteration. Looking at regular expressions will help you develop a full-featured toolkit for processing strings and bodies of text. 
